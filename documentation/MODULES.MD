# MODULES.md

Ce document d√©crit l‚Äôint√©gration des **modules fonctionnels** (Mood, Goals, ‚Ä¶) c√¥t√© UI et leur contrat avec le backend PocketBase.

- UI/UX : **ne pas modifier ici** (voir composants dans `src/modules/*`).
- S√©curit√©/cryptographie : d√©tails dans `SECURITY.md`.
- Sch√©ma des tables : d√©tails dans `BDD.md`.

---

## 1) Glossaire (rappel)

- **mainKey** : cl√© AES de l‚Äôutilisateur¬∑rice (m√©moire uniquement).
- **module_user_id** : identifiant secondaire opaque pour un module (ex. `m_‚Ä¶`, `g_‚Ä¶`).
- **payload** : donn√©es m√©tier **chiffr√©es** (AES-GCM) stock√©es dans `*_entries.payload`.
- **cipher_iv** : IV AES-GCM (Base64URL).
- **guard** : **preuve HMAC d√©terministe** par entr√©e (champ **hidden** en DB) requise pour `UPDATE`/`DELETE`.  
  D√©rivation : `guardKey = HMAC_SHA256(mainKey, "guard:"+module_user_id)` puis  
  `guard = "g_" + HEX(HMAC_SHA256(guardKey, record.id))`.

---

## 2) Quick-start (int√©gration d‚Äôun module)

1. **Lire la config des modules**
   - R√©cup√©rer `users.modules` (blob chiffr√©), le **d√©chiffrer** avec `mainKey`.
   - Chaque entr√©e de `modules` a la forme `{ enabled: boolean, id: <module_user_id> }`.

2. **Activer un module**
   - G√©n√©rer un `module_user_id` (pr√©fix√© par le module, p.ex. `m_‚Ä¶` pour Mood).
   - Mettre √† jour `users.modules` (re-chiffr√© avec `mainKey`).

3. **CRUD (contrat REST)**
   - **LIST/VIEW** :  
     `GET /api/collections/<module>_entries/records?sid=<module_user_id>`  
     ‚Üí retourne uniquement `items[]` du `sid` donn√© (sans `guard`).
   - **CREATE (2 temps)** :  
     A. `POST` body : `{ module_user_id, payload, cipher_iv, guard: "init" }`  
        (un **hook serveur** copie `"init"` vers le champ **hidden** `guard`).  
     B. Le client re√ßoit `id`, calcule `guard` via HMAC, puis **PATCH de promotion** :  
        `PATCH /api/collections/<module>_entries/records/{id}?sid=<module_user_id>&d=init`  
        body : `{ guard: "<g_xxx calcul√©>" }`.
   - **UPDATE/DELETE** :  
     recalculer `guard` √† la vol√©e, puis appeler :  
     `PATCH|DELETE ‚Ä¶/{id}?sid=<module_user_id>&d=<guard>`.

> Remarques :
> - `payload` et `cipher_iv` sont toujours g√©n√©r√©s c√¥t√© UI (AES-GCM).
> - Le serveur **ne renvoie jamais** `guard` (champ hidden).
> - Aucun stockage local du `guard` n‚Äôest requis : il est **recalculable**.

---

## 3) Structure commune des modules `*_entries`

Toutes les tables d‚Äôentr√©es partagent le m√™me contrat minimal :

| Champ            | Type     | Notes                                                                                                  |
|------------------|----------|--------------------------------------------------------------------------------------------------------|
| `module_user_id` | string   | Id secondaire opaque, requis (cl√© d‚Äôacc√®s via `sid`).                                                  |
| `payload`        | string   | Blob **chiffr√©** (Base64URL).                                                                          |
| `cipher_iv`      | string   | IV AES-GCM (Base64URL).                                                                                |
| `guard`          | string   | **Hidden**. Valeur initiale `"init"`, puis **HMAC d√©terministe** apr√®s promotion (PATCH).              |
| `created`        | datetime | Auto.                                                                                                  |
| `updated`        | datetime | Auto.                                                                                                  |

- **R√®gles PB** (r√©sum√©) :  
  - `list/view` : `record.module_user_id = @request.query.sid`.  
  - `update/delete` : `record.module_user_id = @request.query.sid` **ET** `record.guard = @request.query.d`.  
  - Le **premier PATCH de promotion** passe avec `?d=init`.

- **Pattern `guard`** en sch√©ma : `^(g_[a-z0-9]{32,}|init)$`.

---

## 4) Flux c√¥t√© UI (r√©f√©rence d√©veloppeur)

### 4.1 Lire l‚Äôhistorique d‚Äôun module
1. `GET ‚Ä¶/<module>_entries?sid=<module_user_id>&sort=-created`
2. Pour chaque item : `decryptAESGCM({ iv: cipher_iv, data: payload }, mainKey)`
3. Mapper vers le mod√®le d‚Äôaffichage (selon le module).

### 4.2 Cr√©er une entr√©e (2 temps)
1. Construire `payloadObj` (donn√©es claires attendues par le module).
2. Chiffrer : `{ payload, cipher_iv } = encryptAESGCM(JSON.stringify(payloadObj), mainKey)`.
3. **POST** : `{ module_user_id, payload, cipher_iv, guard: "init" }`  
   ‚Üí R√©ponse : `{ id, created, ‚Ä¶ }`
4. D√©river `guardKey = HMAC_SHA256(mainKey, "guard:"+module_user_id)`  
   Puis `guard = "g_" + HEX(HMAC_SHA256(guardKey, id))`.
5. **PATCH** de promotion :  
   `PATCH ‚Ä¶/{id}?sid=<module_user_id>&d=init` avec body `{ guard }`.

### 4.3 Modifier / Supprimer
- Recalculer le `guard` √† partir de `id` + `module_user_id` + `mainKey`.  
- `PATCH|DELETE ‚Ä¶/{id}?sid=<module_user_id>&d=<guard>`.

---

## 5) Sp√©cifiques par module (payload clair attendu)

> ‚ö†Ô∏è Les **cl√©s internes du payload** doivent rester **stables** : l‚Äôhistorique et les exports s‚Äôappuient dessus.

### 5.1 Mood (`mood_entries`)
- **Payload clair minimal** :
  json
  {
    "date": "YYYY-MM-DD",
    "mood_score": "<-2..+2|string|number>",
    "mood_emoji": "üôÇ",
    "positive1": "string",
    "positive2": "string",
    "positive3": "string",
    "comment": "string|optional",
    "question": "string|optional",
    "answer": "string|optional"
  }
`

* UI : `Form.jsx` construit ce payload, le chiffre et suit le flux **create (2 temps)** ci-dessus.
* History : d√©chiffre puis affiche `date, mood_emoji, mood_score, positive1..3, comment, question/answer`.

### 5.2 Goals (`goals_entries`)

* **Payload clair minimal** (exemple) :

  json
  {
    "date": "YYYY-MM-DD",
    "title": "string",
    "note": "string|optional",
    "status": "open|done|wip"
  }
  
* Flux identique (create 2 temps, list/view, update/delete).

> Ajouter de nouveaux modules : r√©utiliser exactement la **structure commune** (¬ß3) et d√©finir uniquement le **payload clair** attendu.

---

## 6) Hooks serveur (PocketBase)

> D√©tails d‚Äôimpl√©mentation dans `SECURITY.md`. Ici, seulement le **contrat**.

* **Hook Create** : copie le `guard` du **body** vers le champ **hidden** (accepte `"init"`).
* **Hook Promotion** : aucun hook sp√©cial requis ‚Äî c‚Äôest un `PATCH` standard avec `?d=init`.
* **Hidden** : comme `guard` est hidden, il **n‚Äôappara√Æt jamais** dans les r√©ponses API.

---

## 7) Erreurs & validations (guideline UI)

* `Module '<X>' non configur√©` ‚Üí `module_user_id` absent.
* `Cl√© de chiffrement absente` ‚Üí `mainKey` non disponible (demander reconnexion).
* `Missing or invalid guard.` (server) ‚Üí v√©rifier le 2-temps (POST `"init"` puis PATCH) ou le recalcul HMAC.
* Sur erreurs r√©seau : afficher le message brut c√¥t√© UI (composant `FormError`) sans d√©tails techniques sensibles.

---

## 8) Convention & compat

* Pr√©fixes d‚ÄôID secondaires : `m_‚Ä¶` (Mood), `g_‚Ä¶` (Goals), etc.
* Toute table d‚Äôentr√©es = `<module>_entries`.
* Migration depuis l‚Äôancien mod√®le (guard al√©atoire) :

  * Activer le pattern `^(g_[a-z0-9]{32,}|init)$`,
  * Promouvoir les nouveaux enregistrements via PATCH,
  * L‚ÄôUI **n‚Äôa plus besoin** de persister `guard` localement.

---



Quand tu valides celui-ci, je te donne **`BDD.md` complet** (version HMAC).
::contentReference[oaicite:0]{index=0}

