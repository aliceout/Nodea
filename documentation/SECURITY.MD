# SECURITY.md

## üîê S√©curit√© & Chiffrement

Ce document d√©crit **tout le protocole de s√©curit√©** de l‚Äôapplication : gestion des cl√©s, modules, entr√©es, et les √©tapes suivies par l‚ÄôUI (client) et le serveur.

---

## 1. Fichiers de chiffrement

- `src/services/crypto.js`
  - Chiffrement sym√©trique AES-GCM (`seal` / `open`).
  - Helpers al√©atoires (`randomBytes`).
  - PBKDF2 (legacy, √† √©viter sauf compatibilit√©).

- `src/services/webcrypto.js`
  - D√©rivation de cl√© robuste avec Argon2id.
  - Hash SHA-256, HMAC.
  - Encodage base64url, g√©n√©ration al√©atoire s√©curis√©e.

- `src/services/crypto-utils.js`
  - Helpers m√©tiers :
    - `generateModuleUserId` (identifiant secondaire),
    - `hmac` (utilis√© pour la d√©rivation de `guard`).

---

## 2. Concepts cl√©s

- **mainKey** : cl√© AES unique par utilisateur¬∑rice, jamais stock√©e en clair c√¥t√© serveur.  
- **modules** : configuration chiffr√©e, stock√©e dans `users.modules`.  
- **module_user_id** : identifiant secondaire, opaque, sert √† grouper les entr√©es d‚Äôun module.  
- **guard** : valeur **d√©riv√©e par HMAC** (d√©terministe) pour chaque entr√©e (`*_entries`), utilis√©e comme preuve de capacit√© pour modification/suppression. Le serveur ne recalcule rien : il stocke le `guard` (champ hidden) et v√©rifie l‚Äô√©galit√© avec `?d=` sur UPDATE/DELETE.  
- **payload** : donn√©es m√©tier (mood, goals, etc.), toujours chiffr√©es c√¥t√© client.  
- **cipher_iv** : vecteur d‚Äôinitialisation unique par payload.

### D√©rivation HMAC du `guard`

Objectif : ne rien stocker c√¥t√© client, tout en pouvant toujours recalculer le secret pour une entr√©e donn√©e.

- **Cl√© par module (c√¥t√© client)** :  
  `guardKey = HMAC_SHA256(mainKey, "guard:" + module_user_id)`  
  *(via WebCrypto/HMAC)*

- **Guard d‚Äôune entr√©e** (d√©terministe) :  
  `guard = "g_" + HEX( HMAC_SHA256(guardKey, record.id) )`  
  (HEX sur 32 octets ‚Üí 64 caract√®res, pr√©fix√©s par `g_`)

- **Flux de cr√©ation en 2 temps** :  
  1) **POST create** avec `guard="init"` (placeholder).  
     Un **hook PocketBase** copie le `guard` re√ßu dans le **champ hidden** de l‚Äôenregistrement (le client ne peut pas √©crire un champ hidden).  
  2) Le client re√ßoit `id`, calcule le `guard` (HMAC ci-dessus), puis **PATCH** l‚Äôentr√©e pour remplacer `"init"` par la vraie valeur, en passant `?sid=<module_user_id>&d=init` (autoris√© car la valeur actuelle est `"init"`).

- **Update/Delete ult√©rieurs** :  
  le client recalcule √† la vol√©e `guard = "g_" + HEX(HMAC_SHA256(guardKey, id))` et appelle  
  `...?sid=<module_user_id>&d=<guard>`.

üëâ R√©sultat : **pas de stockage local** du `guard` ; suppression/modif toujours possibles tant que `mainKey` et `module_user_id` sont connus.

---

## 3. Processus d√©taill√©s

### 3.1 Cr√©ation de compte
1. L‚Äôutilisateur choisit un mot de passe.  
2. **UI** : g√©n√®re un `salt` al√©atoire.  
3. **UI** : d√©rive une cl√© de protection avec Argon2id(password, salt).  
4. **UI** : g√©n√®re une `mainKey` al√©atoire (AES).  
5. **UI** : chiffre la `mainKey` avec la cl√© de protection (`seal`).  
6. **UI ‚Üí serveur** : envoie `{ encrypted_key, encryption_salt }`.  
7. **Serveur** : stocke dans `users.encrypted_key` et `users.encryption_salt`.

### 3.2 Connexion / d√©verrouillage
1. L‚Äôutilisateur entre son mot de passe.  
2. **UI** : r√©cup√®re `encrypted_key` + `encryption_salt` depuis `users`.  
3. **UI** : d√©rive la cl√© de protection avec Argon2id(password, salt).  
4. **UI** : d√©chiffre `encrypted_key` pour retrouver la `mainKey`.  
5. La `mainKey` reste uniquement en m√©moire c√¥t√© client.

### 3.3 Activation d‚Äôun module
1. **UI** : g√©n√®re un `module_user_id` (al√©atoire, base64url).  
2. **UI** : construit un objet `{ enabled: true, id: module_user_id }`.  
3. **UI** : chiffre l‚Äôobjet complet `modules` avec la `mainKey` (`seal`).  
4. **UI ‚Üí serveur** : met √† jour `users.modules`.

### 3.4 Cr√©ation d‚Äôune entr√©e (2 temps)
1. **UI** : pr√©pare `payloadObj`.  
2. **UI** : chiffre avec la `mainKey` ‚Üí obtient `{ payload, cipher_iv }`.  
3. **UI ‚Üí serveur (A)** : `POST /<module>_entries` avec `{ module_user_id, payload, cipher_iv, guard: "init" }`.  
   - Hook PB : copie `"init"` vers le champ **hidden** `guard`.  
4. **UI ‚Üê serveur** : re√ßoit `record.id`.  
5. **UI** : d√©rive `guardKey = HMAC_SHA256(mainKey, "guard:" + module_user_id)` puis  
   `guard = "g_" + HEX(HMAC_SHA256(guardKey, record.id))`.  
6. **UI ‚Üí serveur (B)** : **PATCH de promotion** de l‚Äôentr√©e avec `?sid=<module_user_id>&d=init` et body `{ guard: <guard d√©riv√©> }`.

### 3.5 Lecture d‚Äôune entr√©e
1. **UI ‚Üí serveur** : `GET /<module>_entries?sid=<module_user_id>`.  
2. **Serveur** : renvoie les entr√©es chiffr√©es (payload + iv, **sans** `guard`).  
3. **UI** : d√©chiffre chaque `payload` avec la `mainKey`.

### 3.6 Modification / suppression
1. **UI** : recalcule `guard` √† partir de `mainKey`, `module_user_id` et `record.id`.  
2. **UI ‚Üí serveur** : `PATCH`/**`DELETE`** `/.../{id}?sid=<module_user_id>&d=<guard>`.  
3. **PocketBase** : v√©rifie `module_user_id` ET `guard` (√©galit√© stricte) avant d‚Äôaccepter.

### 3.7 Changement de mot de passe
1. **UI** : demande l‚Äôancien + le nouveau mot de passe.  
2. **UI** : red√©rive la `mainKey` avec l‚Äôancien mot de passe (comme connexion).  
3. **UI** : d√©rive une nouvelle cl√© de protection (Argon2id) avec le nouveau mot de passe.  
4. **UI** : re-scelle la `mainKey` avec cette nouvelle cl√©.  
5. **UI ‚Üí serveur** : met √† jour `users.encrypted_key` et `users.encryption_salt`.

---

## 4. R√¥les : qui fait quoi ?

- **UI (client)**  
  - G√©n√®re les secrets (`mainKey`, `module_user_id`, `iv`).  
  - D√©rive `guardKey` et `guard` via HMAC (d√©terministe).  
  - Chiffre/d√©chiffre tous les `payloads`.  
  - Envoie uniquement des donn√©es chiffr√©es au serveur.

- **Serveur (PocketBase)**  
  - Stocke les blobs chiffr√©s (`encrypted_key`, `modules`, `payloads`).  
  - Stocke le `guard` (champ hidden) et applique les r√®gles d‚Äôacc√®s (`module_user_id` + `guard`).  
  - Ne conna√Æt jamais les cl√©s r√©elles.

---

## 5. R√©sum√© s√©curit√©

- **End-to-end** : le serveur ne voit jamais les donn√©es d√©chiffr√©es.  
- **Capability-based** : l‚Äôacc√®s d√©pend uniquement de `module_user_id` + `guard`.  
- **Pas de lien direct avec user.id** : emp√™che la corr√©lation entre donn√©es chiffr√©es et utilisateurs.  
- **Argon2id** : emp√™che le brute-force des mots de passe.  
- **AES-GCM** : assure confidentialit√© + int√©grit√© des donn√©es.  
- **HMAC (guard)** : suppression/modif sans stockage local, recalcul √† la demande.

---

## 6. FAQ technique

**Que se passe-t-il si l‚Äôutilisateur ouvre un autre onglet ou red√©marre l‚Äôapp ?**  
La `mainKey` est volatile. Elle est d√©riv√©e du mot de passe √† chaque session via Argon2id et **n‚Äôest jamais persist√©e**. Aucune donn√©e n‚Äôest accessible tant que `mainKey` n‚Äôest pas disponible en m√©moire.

**Peut-on pr√©charger les modules automatiquement apr√®s connexion ?**  
Oui. Une fois la `mainKey` d√©riv√©e, l‚ÄôUI peut d√©crypter `users.modules` et initialiser les modules actifs.

---

## 7. R√®gles d‚Äôacc√®s PocketBase (r√©sum√©)

- **list/view** :  
  `request.query.sid != ""` **et** `record.module_user_id = request.query.sid`

- **update/delete** :  
  `request.query.sid != ""` **et** `request.query.d != ""` **et**  
  `record.module_user_id = request.query.sid` **et** `record.guard = request.query.d`

*(En cr√©ation, le hook autorise `guard="init"` puis le PATCH de promotion avec `?d=init`.)*

---

## 8. Glossaire rapide

- `module_user_id` : identifiant secondaire unique par module  
- `payload` : contenu chiffr√©  
- `guard` : preuve HMAC requise pour update/delete (champ hidden c√¥t√© serveur)  
- `mainKey` : cl√© AES propre √† l‚Äôutilisateur¬∑rice

---

## 9. Convention de nommage

- Pr√©fixes d‚Äô`id` : `m_` pour Mood, `g_` pour Goals, etc.  
- Tables PB : `<module>_entries`  
- Stores frontend : `modulesState`  
- Cl√©s JSON de `users.modules` = noms de modules dans le code
