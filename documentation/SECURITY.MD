# SECURITY.md

## üîê S√©curit√© & Chiffrement

Ce document d√©crit **tout le protocole de s√©curit√©** de l‚Äôapplication : gestion des cl√©s, modules, entr√©es, et les √©tapes suivies par l‚ÄôUI (client) et le serveur.

---

## 1. Fichiers de chiffrement

- `src/services/crypto.js`
  - Chiffrement sym√©trique AES-GCM (`seal` / `open`).
  - Helpers al√©atoires (`randomBytes`).
  - PBKDF2 (legacy, √† √©viter sauf compatibilit√©).

- `src/services/webcrypto.js`
  - D√©rivation de cl√© robuste avec Argon2id.
  - Hash SHA-256, HMAC.
  - Encodage base64url, g√©n√©ration al√©atoire s√©curis√©e.

- `src/services/crypto-utils.js`
  - Helpers m√©tiers :
    - `generateModuleUserId` (identifiant secondaire),
    - `makeGuard` (secret guard par entr√©e),
    - `hashPayload`, `hmac`.

---

## 2. Concepts cl√©s

- **mainKey** : cl√© AES unique par utilisateur¬∑rice, jamais stock√©e en clair c√¥t√© serveur.  
- **modules** : configuration chiffr√©e, stock√©e dans `users.modules`.  
- **module_user_id** : identifiant secondaire, opaque, sert √† grouper les entr√©es d‚Äôun module.  
- **guard** : secret al√©atoire associ√© √† chaque entr√©e (`*_entries`), utilis√© comme preuve de capacit√© pour modification/suppression.  
- **payload** : donn√©es m√©tier (mood, goals, etc.), toujours chiffr√©es c√¥t√© client.  
- **cipher_iv** : vecteur d‚Äôinitialisation unique par payload.

---

## 3. Processus d√©taill√©s

### 3.1 Cr√©ation de compte
1. L‚Äôutilisateur choisit un mot de passe.  
2. **UI** : g√©n√®re un `salt` al√©atoire.  
3. **UI** : d√©rive une cl√© de protection avec Argon2id(password, salt).  
4. **UI** : g√©n√®re une `mainKey` al√©atoire (AES).  
5. **UI** : chiffre la `mainKey` avec la cl√© de protection (`seal`).  
6. **UI ‚Üí serveur** : envoie `{ encrypted_key, encryption_salt }`.  
7. **Serveur** : stocke dans `users.encrypted_key` et `users.encryption_salt`.

---

### 3.2 Connexion / d√©verrouillage
1. L‚Äôutilisateur entre son mot de passe.  
2. **UI** : r√©cup√®re `encrypted_key` + `encryption_salt` depuis `users`.  
3. **UI** : d√©rive la cl√© de protection avec Argon2id(password, salt).  
4. **UI** : d√©chiffre `encrypted_key` pour retrouver la `mainKey`.  
5. La `mainKey` reste uniquement en m√©moire c√¥t√© client.

---

### 3.3 Activation d‚Äôun module
1. **UI** : g√©n√®re un `module_user_id` (al√©atoire, base64url).  
2. **UI** : construit un objet `{ enabled: true, id: module_user_id }`.  
3. **UI** : chiffre l‚Äôobjet complet `modules` avec la `mainKey` (`seal`).  
4. **UI ‚Üí serveur** : met √† jour `users.modules`.

---

### 3.4 Cr√©ation d‚Äôune entr√©e
1. **UI** : pr√©pare le contenu (`payloadObj`).  
2. **UI** : chiffre avec la `mainKey` ‚Üí obtient `{ payload, cipher_iv }`.  
3. **UI** : g√©n√®re un `guard` (al√©atoire, pr√©fix√© `g_...`).  
4. **UI ‚Üí serveur** : `POST /<module>_entries` avec `{ module_user_id, payload, cipher_iv, guard }`.  
5. **PocketBase rules** :
   - create = user connect√©  
   - list/view = `?sid=module_user_id`  
   - update/delete = `?sid=...&d=guard`

---

### 3.5 Lecture d‚Äôune entr√©e
1. **UI ‚Üí serveur** : `GET /<module>_entries?sid=<module_user_id>`.  
2. **Serveur** : renvoie les entr√©es chiffr√©es (payload + iv).  
3. **UI** : d√©chiffre chaque `payload` avec la `mainKey`.  
4. L‚Äôutilisateur¬∑rice ne voit que les donn√©es d√©chiffr√©es localement.

---

### 3.6 Modification / suppression
1. **UI ‚Üí serveur** : `PATCH` ou `DELETE /<module>_entries/{id}?sid=<module_user_id>&d=<guard>`.  
2. **PocketBase** : v√©rifie que `module_user_id` correspond et que `guard` est correct.  
3. Si OK, l‚Äôop√©ration est accept√©e.

---

### 3.7 Changement de mot de passe
1. **UI** : demande le mot de passe actuel + le nouveau.  
2. **UI** : red√©rive la `mainKey` avec l‚Äôancien mot de passe (comme connexion).  
3. **UI** : d√©rive une nouvelle cl√© de protection avec le nouveau mot de passe (Argon2id).  
4. **UI** : re-scelle la `mainKey` avec cette nouvelle cl√©.  
5. **UI ‚Üí serveur** : met √† jour `users.encrypted_key` et `users.encryption_salt`.

---

## 4. R√¥les : qui fait quoi ?

- **UI (client)**  
  - G√©n√®re les secrets (`mainKey`, `module_user_id`, `guard`, `iv`).  
  - D√©rive les cl√©s √† partir du mot de passe (Argon2id).  
  - Chiffre/d√©chiffre tous les `payloads`.  
  - Envoie uniquement des donn√©es chiffr√©es au serveur.  

- **Serveur (PocketBase)**  
  - Stocke les blobs chiffr√©s (`encrypted_key`, `modules`, `payloads`).  
  - Applique les r√®gles d‚Äôacc√®s (`module_user_id` + `guard`).  
  - Ne conna√Æt jamais les cl√©s r√©elles.

---

## 5. R√©sum√© s√©curit√©

- **End-to-end** : le serveur ne voit jamais les donn√©es d√©chiffr√©es.  
- **Capability-based** : l‚Äôacc√®s d√©pend uniquement de `module_user_id` + `guard`.  
- **Pas de lien direct avec user.id** : emp√™che la corr√©lation entre donn√©es chiffr√©es et utilisateurs.  
- **Argon2id** : emp√™che le brute-force des mots de passe.  
- **AES-GCM** : assure confidentialit√© + int√©grit√© des donn√©es.  
- **Random crypto-safe** : toutes les valeurs critiques viennent de `crypto.getRandomValues`.

---

## 6. FAQ technique

### Que se passe-t-il si l‚Äôutilisateur ouvre un autre onglet ou red√©marre l‚Äôapp ?
La `mainKey` est volatile. Elle est d√©riv√©e du mot de passe √† chaque session via Argon2id et **n‚Äôest jamais persist√©e**.  
Chaque nouvel onglet ou red√©marrage doit redemander le mot de passe pour re-d√©verrouiller les modules.  
Aucune donn√©e n‚Äôest accessible tant que `mainKey` n‚Äôest pas disponible en m√©moire.

### Peut-on pr√©charger les modules automatiquement apr√®s connexion ?
Oui, une fois la `mainKey` d√©riv√©e, l‚ÄôUI peut d√©crypter automatiquement `users.modules` et initialiser tous les modules actifs dans le store.

---
